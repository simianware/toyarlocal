"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.txRawDataRoute = exports.txFileRoute = exports.txFieldRoute = exports.txStatusRoute = exports.txPostRoute = exports.txOffsetRoute = exports.txRoute = exports.txAnchorRoute = exports.pathRegex = void 0;
const transaction_1 = require("../db/transaction");
const data_1 = require("../db/data");
const utils_1 = require("../utils/utils");
const arbundles_1 = require("arbundles");
const wallet_1 = require("../db/wallet");
const encoding_1 = require("../utils/encoding");
const chunks_1 = require("../db/chunks");
exports.pathRegex = /^\/?([a-z0-9-_]{43})/i;
let transactionDB;
let dataDB;
let walletDB;
let chunkDB;
let oldDbPath;
let connectionSettings;
const FIELDS = [
    'id',
    'last_tx',
    'owner',
    'tags',
    'target',
    'quantity',
    'data_root',
    'data_size',
    'reward',
    'signature',
];
function txAnchorRoute(ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        const txs = yield ctx.connection.select('id').from('blocks').limit(1);
        if (txs.length) {
            ctx.body = txs[0].id;
            return;
        }
        ctx.body = '';
    });
}
exports.txAnchorRoute = txAnchorRoute;
function txRoute(ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (oldDbPath !== ctx.dbPath ||
                !transactionDB ||
                connectionSettings !== ctx.connection.client.connectionSettings.filename) {
                transactionDB = new transaction_1.TransactionDB(ctx.connection);
                oldDbPath = ctx.dbPath;
                connectionSettings = ctx.connection.client.connectionSettings.filename;
            }
            const path = ctx.params.txid.match(exports.pathRegex) || [];
            const transaction = path.length > 1 ? path[1] : '';
            const metadata = yield transactionDB.getById(transaction);
            ctx.logging.log(metadata);
            if (!metadata) {
                ctx.status = 404;
                ctx.body = { status: 404, error: 'Not Found' };
                return;
            }
            ctx.status = 200;
            ctx.headers['accept-ranges'] = 'bytes';
            ctx.headers['content-length'] = metadata.data_size;
            ctx.body = metadata;
        }
        catch (error) {
            console.error({ error });
        }
    });
}
exports.txRoute = txRoute;
function txOffsetRoute(ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (!transactionDB) {
                transactionDB = new transaction_1.TransactionDB(ctx.connection);
            }
            if (!chunkDB) {
                chunkDB = new chunks_1.ChunkDB(ctx.connection);
            }
            const path = ctx.params.txid.match(exports.pathRegex) || [];
            const transaction = path.length > 1 ? path[1] : '';
            const metadata = yield transactionDB.getById(transaction);
            ctx.logging.log(metadata);
            if (!metadata) {
                ctx.status = 404;
                ctx.body = { status: 404, error: 'Not Found' };
                return;
            }
            const chunk = yield chunkDB.getByRootAndSize(metadata.data_root, metadata.data_size);
            ctx.status = 200;
            ctx.type = 'text/plain'; // TODO: updated this in arweave gateway to app/json
            ctx.body = { offset: +chunk.offset, size: metadata.data_size };
        }
        catch (error) {
            console.error({ error });
        }
    });
}
exports.txOffsetRoute = txOffsetRoute;
function txPostRoute(ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (oldDbPath !== ctx.dbPath || !dataDB || !walletDB) {
                dataDB = new data_1.DataDB(ctx.dbPath);
                walletDB = new wallet_1.WalletDB(ctx.connection);
                oldDbPath = ctx.dbPath;
            }
            const data = ctx.request.body;
            ctx.logging.log('post', data);
            let bundleFormat = '';
            let bundleVersion = '';
            for (const tag of data.tags) {
                const name = utils_1.Utils.atob(tag.name);
                const value = utils_1.Utils.atob(tag.value);
                if (name === 'Bundle-Format')
                    bundleFormat = value;
                if (name === 'Bundle-Version')
                    bundleVersion = value;
            }
            if (bundleFormat === 'binary' && bundleVersion === '2.0.0') {
                // ANS-104
                const buffer = Buffer.from(data.data, 'base64');
                const bundle = new arbundles_1.Bundle(buffer);
                const items = bundle.items;
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    yield txPostRoute(Object.assign(Object.assign({}, ctx), { connection: ctx.connection, logging: ctx.logging, network: ctx.network, request: Object.assign(Object.assign({}, ctx.request), { body: Object.assign({ id: bundle.getIdBy(i) }, item.toJSON()) }) }));
                }
            }
            const owner = encoding_1.bufferTob64Url(yield encoding_1.hash(encoding_1.b64UrlToBuffer(data.owner)));
            // BALANCE UPDATES
            if ((data === null || data === void 0 ? void 0 : data.target) && (data === null || data === void 0 ? void 0 : data.quantity)) {
                const fromWallet = yield walletDB.getWallet(owner);
                const targetWallet = yield walletDB.getWallet(data.target);
                if (!fromWallet || !targetWallet) {
                    ctx.status = 404;
                    ctx.body = { status: 404, error: `Wallet not found` };
                    return;
                }
                if ((fromWallet === null || fromWallet === void 0 ? void 0 : fromWallet.balance) < +data.quantity + +data.reward) {
                    ctx.status = 403;
                    ctx.body = { status: 403, error: `you don't have enough funds to send ${data.quantity}` };
                    return;
                }
                yield walletDB.incrementBalance(data.target, +data.quantity);
                yield walletDB.incrementBalance(data.owner, -data.quantity);
            }
            yield walletDB.incrementBalance(data.owner, -data.reward);
            yield dataDB.insert({ txid: data.id, data: data.data });
            const tx = transaction_1.formatTransaction(data);
            tx.created_at = new Date().toISOString();
            tx.height = ctx.network.blocks;
            yield ctx.connection.insert(tx).into('transactions');
            let index = 0;
            for (const tag of data.tags) {
                const name = utils_1.Utils.atob(tag.name);
                const value = utils_1.Utils.atob(tag.value);
                ctx.logging.log(name, value);
                yield ctx.connection
                    .insert({
                    index,
                    tx_id: tx.id,
                    name,
                    value,
                })
                    .into('tags');
                index++;
            }
            ctx.body = data;
        }
        catch (error) {
            console.error({ error });
        }
    });
}
exports.txPostRoute = txPostRoute;
function txStatusRoute(ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (oldDbPath !== ctx.dbPath ||
                !transactionDB ||
                connectionSettings !== ctx.connection.client.connectionSettings.filename) {
                transactionDB = new transaction_1.TransactionDB(ctx.connection);
                oldDbPath = ctx.dbPath;
                connectionSettings = ctx.connection.client.connectionSettings.filename;
            }
            const path = ctx.params.txid.match(exports.pathRegex) || [];
            const transaction = path.length > 1 ? path[1] : '';
            const metadata = yield transactionDB.getById(transaction);
            if (!metadata) {
                ctx.status = 404;
                ctx.body = { status: 404, error: 'Not Found !' };
                return;
            }
            if (!metadata.block) {
                ctx.body = 'Pending';
                return;
            }
            ctx.body = {
                block_height: metadata.height,
                block_indep_hash: metadata.block,
                number_of_confirmations: ctx.network.height - metadata.height,
            };
            return;
        }
        catch (error) {
            console.error({ error });
        }
    });
}
exports.txStatusRoute = txStatusRoute;
function txFieldRoute(ctx, next) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (oldDbPath !== ctx.dbPath ||
                !transactionDB ||
                connectionSettings !== ctx.connection.client.connectionSettings.filename) {
                transactionDB = new transaction_1.TransactionDB(ctx.connection);
                oldDbPath = ctx.dbPath;
                connectionSettings = ctx.connection.client.connectionSettings.filename;
            }
            const path = ctx.params.txid.match(exports.pathRegex) || [];
            const transaction = path.length > 1 ? path[1] : '';
            const field = ctx.params.field;
            if (field.includes('.')) {
                yield next();
                return;
            }
            if (!FIELDS.includes(field)) {
                ctx.status = 404;
                ctx.body = { status: 404, error: 'Field Not Found !' };
                return;
            }
            const metadata = yield transactionDB.getById(transaction);
            if (!metadata) {
                ctx.status = 404;
                ctx.body = { status: 404, error: 'Not Found !' };
                return;
            }
            if (!metadata.block) {
                ctx.body = 'Pending';
                return;
            }
            ctx.body = metadata[field];
            return;
        }
        catch (error) {
            console.error({ error });
        }
    });
}
exports.txFieldRoute = txFieldRoute;
function txFileRoute(ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (oldDbPath !== ctx.dbPath ||
                !transactionDB ||
                connectionSettings !== ctx.connection.client.connectionSettings.filename) {
                transactionDB = new transaction_1.TransactionDB(ctx.connection);
                oldDbPath = ctx.dbPath;
                connectionSettings = ctx.connection.client.connectionSettings.filename;
            }
            const path = ctx.params.txid.match(exports.pathRegex) || [];
            const transaction = path.length > 1 ? path[1] : '';
            const file = ctx.params.file;
            const metadata = yield transactionDB.getById(transaction);
            if (!metadata) {
                ctx.status = 404;
                ctx.body = { status: 404, error: 'Not Found !' };
                return;
            }
            if (!metadata.block) {
                ctx.body = 'Pending';
                return;
            }
            ctx.redirect(`http://${ctx.request.header.host}/${transaction}/${file}`);
            return;
        }
        catch (error) {
            console.error({ error });
        }
    });
}
exports.txFileRoute = txFileRoute;
function txRawDataRoute(ctx) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (!transactionDB ||
                !dataDB ||
                oldDbPath !== ctx.dbPath ||
                connectionSettings !== ctx.connection.client.connectionSettings.filename) {
                transactionDB = new transaction_1.TransactionDB(ctx.connection);
                dataDB = new data_1.DataDB(ctx.dbPath);
                oldDbPath = ctx.dbPath;
                connectionSettings = ctx.connection.client.connectionSettings.filename;
            }
            const path = ctx.params.txid.match(exports.pathRegex) || [];
            const txid = path.length > 1 ? path[1] : '';
            const metadata = yield transactionDB.getById(txid);
            if (!metadata) {
                ctx.status = 404;
                ctx.body = { status: 404, error: 'Not found' };
                return;
            }
            // Check for the data_size
            const size = parseInt(metadata.data_size, 10);
            if (size > 12000000) {
                ctx.status = 400;
                ctx.body = 'tx_data_too_big';
                return;
            }
            // Find the transaction data
            const data = yield dataDB.findOne(txid);
            // Return the base64 data to the user
            ctx.status = 200;
            ctx.body = data.data;
        }
        catch (error) {
            ctx.status = 500;
            ctx.body = { error: error.message };
        }
    });
}
exports.txRawDataRoute = txRawDataRoute;
//# sourceMappingURL=transaction.js.map